// LIBRERÍAS
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <complex.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <stdint.h>
#include <windows.h>

// PARÁMETROS CRC SEGÚN 3GPP TS 36.212
#define CRC24A_POLY 0x1864CFB
#define CRC24A_LEN 24

// PARÁMETROS NB-IoT
#define TB_SIZE_BITS 24
#define CRC_TYPE CRC24A_LEN
#define TOTAL_BITS (TB_SIZE_BITS + CRC_TYPE)
#define REPETITION_FACTOR 3
#define TOTAL_BITS_REPEATED (TOTAL_BITS * REPETITION_FACTOR)
#define BPS 2
#define TOTAL_SYMBOLS (TOTAL_BITS_REPEATED / BPS)

// PARÁMETROS ENTRELAZADO
#define INTERLEAVER_ROWS 12 // IN_ROWS * IN_COLS = TOTAL_BITS_REPEATED
#define INTERLEAVER_COLS 12
#define INTERLEAVER_SIZE (INTERLEAVER_ROWS * INTERLEAVER_COLS)

// PARÁMETROS MODULACIÓN
#define ANGLE_STEP 2.3997569
#define C_POINTS 4

// PARÁMETROS OFDM
#define N_FFT 128 // N_FFT > TOTAL_SYMBOLS
#define SUBCARRIERS TOTAL_SYMBOLS
#define CP_LEN 10
#define SUBCARRIERS_START (N_FFT/2 - SUBCARRIERS/2)

// PARÁMETROS CANAL
#define SNR 3.0


// ESTRUCTURAS
typedef struct {
    float complex point;
    int bits[BPS];
} Constellation;

typedef struct {
    int data_bits[TB_SIZE_BITS];
    int crc_bits[CRC_TYPE];
    int total_bits[TOTAL_BITS];
    int repeated_bits[TOTAL_BITS_REPEATED];
    int interleaved_bits[TOTAL_BITS_REPEATED];
    bool crc_valid;
} TransportBlock;


// FUNCIONES ENTRELAZADO
bool interleave_bits(const int input_bits[TOTAL_BITS_REPEATED], int output_bits[TOTAL_BITS_REPEATED])
{
    if (TOTAL_BITS_REPEATED != INTERLEAVER_SIZE)
    {
        printf("Error: Tamaño de entrelazado no coincide\n");
        return true;
    }

    int matrix[INTERLEAVER_ROWS][INTERLEAVER_COLS];
    int idx = 0;

    // Llenar matriz por filas
    for (int i = 0; i < INTERLEAVER_ROWS; i++)
    {
        for (int j = 0; j < INTERLEAVER_COLS; j++)
        {
            matrix[i][j] = input_bits[idx++];
        }
    }

    // Leer matriz por columnas (entrelazado)
    idx = 0;
    for (int j = 0; j < INTERLEAVER_COLS; j++)
    {
        for (int i = 0; i < INTERLEAVER_ROWS; i++)
        {
            output_bits[idx++] = matrix[i][j];
        }
    }

    return false;
}

bool deinterleave_bits(const int input_bits[TOTAL_BITS_REPEATED], int output_bits[TOTAL_BITS_REPEATED])
{
    if (TOTAL_BITS_REPEATED != INTERLEAVER_SIZE)
    {
        printf("Error: Tamaño de entrelazado no coincide\n");
        return true;
    }

    int matrix[INTERLEAVER_ROWS][INTERLEAVER_COLS];
    int idx = 0;

    // Llenar matriz por columnas
    for (int j = 0; j < INTERLEAVER_COLS; j++)
    {
        for (int i = 0; i < INTERLEAVER_ROWS; i++)
        {
            matrix[i][j] = input_bits[idx++];
        }
    }

    // Leer matriz por filas (desentrelazado)
    idx = 0;
    for (int i = 0; i < INTERLEAVER_ROWS; i++)
    {
        for (int j = 0; j < INTERLEAVER_COLS; j++)
        {
            output_bits[idx++] = matrix[i][j];
        }
    }

    return false;
}


// FUNCIONES CRC
void calculate_crc24a(const int data_bits[TB_SIZE_BITS], int crc_bits[CRC24A_LEN])
{
    uint32_t crc = 0xFFFFFF;

    for (int i = 0; i < TB_SIZE_BITS; i++)
    {
        crc ^= (data_bits[i] << 23);
        if (crc & 0x800000) {   crc = (crc << 1) ^ CRC24A_POLY;   }
        else {   crc <<= 1;   }
        crc &= 0xFFFFFF;
    }

    for (int i = 0; i < CRC24A_LEN; i++) {   crc_bits[i] = (crc >> (23 - i)) & 1;   }
}

bool verify_crc24a(const int received_bits[TOTAL_BITS])
{
    uint32_t crc = 0xFFFFFF;

    for (int i = 0; i < TOTAL_BITS; i++)
    {
        crc ^= (received_bits[i] << 23);
        if (crc & 0x800000)
        {   crc = (crc << 1) ^ CRC24A_POLY;   }
        else {   crc <<= 1;   }
        crc &= 0xFFFFFF;
    }

    return (crc == 0);
}


// FUNCIONES FEC REPETICIÓN (3,1)
bool repetition_encoder(const int input_bits[TOTAL_BITS], int output_bits[TOTAL_BITS_REPEATED])
{
    for (int i = 0; i < TOTAL_BITS; i++)
    {
        for (int j = 0; j < REPETITION_FACTOR; j++)
        {
            output_bits[i * REPETITION_FACTOR + j] = input_bits[i];
        }
    }
    return false;
}

bool repetition_decoder_hard(const int input_bits[TOTAL_BITS_REPEATED], int output_bits[TOTAL_BITS])
{
    int errors_corrected = 0;

    for (int i = 0; i < TOTAL_BITS; i++)
    {
        int sum = 0;
        for (int j = 0; j < REPETITION_FACTOR; j++)
        {
            sum += input_bits[i * REPETITION_FACTOR + j];
        }

        // DECODIFICACIÓN HARD POR MAYORÍA
        int decoded_bit = (sum >= 2) ? 1 : 0;
        output_bits[i] = decoded_bit;

        // Contar correcciones
        int original_bit = input_bits[i * REPETITION_FACTOR];
        if (decoded_bit != original_bit && sum != REPETITION_FACTOR && sum != 0)
        {
            errors_corrected++;
        }
    }

    return false;
}


// FUNCIONES TRANSPORT BLOCK
bool build_transport_block(TransportBlock *tb, const int data_bits[TB_SIZE_BITS])
{
    for (int i = 0; i < TB_SIZE_BITS; i++) {   tb->data_bits[i] = data_bits[i];   }

    calculate_crc24a(data_bits, tb->crc_bits);

    int idx = 0;
    for (int i = 0; i < TB_SIZE_BITS; i++) tb->total_bits[idx++] = data_bits[i];
    for (int i = 0; i < CRC_TYPE; i++) tb->total_bits[idx++] = tb->crc_bits[i];

    // APLICAMOS CODIFICACIÓN FEC POR REPETICIÓN
    repetition_encoder(tb->total_bits, tb->repeated_bits);

    // APLICAMOS ENTRELAZADO PARA LOS ERRORES DE RÁFAGA
    interleave_bits(tb->repeated_bits, tb->interleaved_bits);

    tb->crc_valid = true;
    return false;
}

bool process_received_block(const int received_bits[TOTAL_BITS_REPEATED], TransportBlock *tb)
{
    int deinterleaved_bits[TOTAL_BITS_REPEATED];
    int decoded_bits[TOTAL_BITS];

    // DESENTRELAZAMOS PARA OBTENER EL ORDEN ORIGINAL
    deinterleave_bits(received_bits, deinterleaved_bits);

    // APLICAMOS DECODIFICACIÓN FEC POR REPETICIÓN
    repetition_decoder_hard(deinterleaved_bits, decoded_bits);

    // EXTRAEMOS DATOS Y CRC
    for (int i = 0; i < TB_SIZE_BITS; i++) tb->data_bits[i] = decoded_bits[i];
    for (int i = 0; i < CRC_TYPE; i++) tb->crc_bits[i] = decoded_bits[TB_SIZE_BITS + i];

    tb->crc_valid = verify_crc24a(decoded_bits);

    return !tb->crc_valid;
}


// FUNCIONES DATASOURCE
bool generate_random_bits(int bits[TB_SIZE_BITS])
{
    for (int i = 0; i < TB_SIZE_BITS; i++) bits[i] = rand() % 2;
    return false;
}

float calculate_ber(const int tx_bits[TB_SIZE_BITS], const int rx_bits[TB_SIZE_BITS])
{
    int errors = 0;
    for (int i = 0; i < TB_SIZE_BITS; i++)
    {
        if (tx_bits[i] != rx_bits[i]) errors++;
    }
    return (float)errors / TB_SIZE_BITS;
}

float calculate_bler (int successful_transmissions, int total_transmissions)
{
    float bler = ((float)(total_transmissions - successful_transmissions)/total_transmissions);
    return bler;
}


// FUNCIONES MODULADOR
bool init_golden_modulation(Constellation constellation[C_POINTS])
{
    float total_power = 0.0f;

    for (int i = 0; i < C_POINTS; i++)
    {
        float angle = (i + 1) * ANGLE_STEP;
        float radius = sqrtf(i + 1);
        constellation[i].point = radius * (cosf(angle) + sinf(angle)*I);
        total_power += crealf(constellation[i].point) * crealf(constellation[i].point) +
                       cimagf(constellation[i].point) * cimagf(constellation[i].point);

        // ASIGNAMOS BITS SEGÚN CODIFICACIÓN GRAY
        if (i == 0) { constellation[i].bits[0] = 0; constellation[i].bits[1] = 0; }
        else if (i == 1) { constellation[i].bits[0] = 0; constellation[i].bits[1] = 1; }
        else if (i == 2) { constellation[i].bits[0] = 1; constellation[i].bits[1] = 1; }
        else if (i == 3) { constellation[i].bits[0] = 1; constellation[i].bits[1] = 0; }
        else return true;
    }

    float norm_factor = sqrtf(total_power / C_POINTS);
    for (int i = 0; i < C_POINTS; i++) {   constellation[i].point /= norm_factor;   }

    return false;
}

bool golden_modulation_hard(const int interleaved_bits[TOTAL_BITS_REPEATED], float complex symbols[TOTAL_SYMBOLS])
{
    Constellation temp_const[C_POINTS];
    if (init_golden_modulation(temp_const)) return true;

    for (int i = 0; i < TOTAL_SYMBOLS; i++)
    {
        int ibits = i * BPS;
        bool found = false;

        // MODULAMOS LOS BITS A TX SEGÚN LA CONSTELACIÓN
        for (int j = 0; j < C_POINTS; j++)
        {
            if (temp_const[j].bits[0] == interleaved_bits[ibits] && temp_const[j].bits[1] == interleaved_bits[ibits + 1])
            {
                symbols[i] = temp_const[j].point;
                found = true;
                break;
            }
        }
        if (!found) return true;
    }
    return false;
}


// FUNCIONES OFDM
bool mapping_ofdm(const float complex tx_symbols[TOTAL_SYMBOLS], float complex subcarriers[N_FFT])
{
    if (SUBCARRIERS_START + SUBCARRIERS >= N_FFT) return true;

    for (int i = 0; i < N_FFT; i++) {   subcarriers[i] = 0.0f + 0.0f*I;   }
    for (int i = 0; i < SUBCARRIERS; i++) {   subcarriers[SUBCARRIERS_START + i] = tx_symbols[i];   }

    return false;
}

void idft(const float complex subcarriers[N_FFT], float complex ofdm_symbols[N_FFT])
{
    for (int n = 0; n < N_FFT; n++)
    {
        ofdm_symbols[n] = 0 + 0.0f*I;

        for (int k = 0; k < N_FFT; k++)
        {
            float angle = (2.0f * M_PI * k * n) / N_FFT;
            ofdm_symbols[n] += subcarriers[k] * (cosf(angle) + sinf(angle)*I);
        }
        ofdm_symbols[n] /= sqrtf(N_FFT);
    }
}

void add_cyclic_prefix(const float complex ofdm_symbol[N_FFT], float complex ofdm_symbol_with_cp[N_FFT + CP_LEN])
{
    for (int i = 0; i < CP_LEN; i++) ofdm_symbol_with_cp[i] = ofdm_symbol[N_FFT - CP_LEN + i];
    for (int i = 0; i < N_FFT; i++) ofdm_symbol_with_cp[CP_LEN + i] = ofdm_symbol[i];
}

void remove_cyclic_prefix(const float complex ofdm_symbol_with_cp[N_FFT + CP_LEN], float complex ofdm_symbol[N_FFT])
{
    for (int i = 0; i < N_FFT; i++) ofdm_symbol[i] = ofdm_symbol_with_cp[CP_LEN + i];
}

void dft(const float complex ofdm_symbols[N_FFT], float complex subcarriers[N_FFT])
{
    for (int k = 0; k < N_FFT; k++)
    {
        subcarriers[k] = 0 + 0.0f*I;

        for (int n = 0; n < N_FFT; n++)
        {
            float angle = (-2.0f * M_PI * k * n) / N_FFT;
            subcarriers[k] += ofdm_symbols[n] * (cosf(angle) + sinf(angle)*I);
        }
        subcarriers[k] /= sqrtf(N_FFT);
    }
}

bool demapping_ofdm(const float complex subcarriers[N_FFT], float complex rx_symbols[TOTAL_SYMBOLS])
{
    if (SUBCARRIERS_START + SUBCARRIERS >= N_FFT) return true;

    for (int i = 0; i < SUBCARRIERS; i++)
    {
        rx_symbols[i] = subcarriers[SUBCARRIERS_START + i];
    }

    return false;
}


// FUNCIONES CANAL
float complex awgn_noise(float stddev)
{
    float u1, u2;
    do {
        u1 = (float)rand() / RAND_MAX;
        u2 = (float)rand() / RAND_MAX;
    } while (u1 <= 1e-10f);

    float radius = sqrtf(-2.0f * logf(u1));
    float angle = 2.0f * M_PI * u2;

    return radius * cosf(angle) * stddev + I * radius * sinf(angle) * stddev;
}

float calculate_mean_power(const float complex symbols[], int length)
{
    float power = 0;
    for (int i = 0; i < length; i++)
    {
        power += crealf(symbols[i]) * crealf(symbols[i]) +
                 cimagf(symbols[i]) * cimagf(symbols[i]);
    }
    return power / length;
}

bool awgn_channel_with_burst_errors(float complex in_symbols[], float complex out_symbols[], int length)
{
    float mean_power = calculate_mean_power(in_symbols, length);
    if (mean_power <= 1e-10f) return true;

    float SNR_lin = powf(10.0f, SNR/10.0f);
    float noise_power = mean_power / SNR_lin;
    float stddev = sqrtf(noise_power / 2.0f);

    // APLICAMOS RUIDO AWGN A LOS TODOS LOS SÍMBOLOS
    for (int i = 0; i < length; i++) {   out_symbols[i] = in_symbols[i] + awgn_noise(stddev);   }

    // SIMULAMOS OCASIONALMENTE ERRORES DE RÁFAGA CON 10% DE PROBABILIDAD
    if (rand() % 100 < 10)
    {
        int burst_start = rand() % (length - 5);
        int burst_length = 3 + rand() % 3; // Ráfaga de 3-5 símbolos

        printf("Simulando error en rafaga en simbolos %d-%d\n", burst_start, burst_start + burst_length);

        for (int i = burst_start; i < burst_start + burst_length && i < length; i++)
        {
            out_symbols[i] = awgn_noise(stddev * 5.0f); // RUIDO 5X MÁS FUERTE EN LAS RÁFAGAS
        }
    }

    return false;
}

bool awgn_channel(float complex in_symbols[], float complex out_symbols[], int length)
{
    return awgn_channel_with_burst_errors(in_symbols, out_symbols, length);
}

// FUNCIONES DEMODULADOR
int calculate_min_distance_hard(float complex symbol, Constellation constellation[C_POINTS])
{
    float min_dist = FLT_MAX;
    int best_index = -1;

    for (int i = 0; i < C_POINTS; i++)
    {
        float complex diff = symbol - constellation[i].point;
        float dist = crealf(diff * conjf(diff));
        if (dist < min_dist)
        {
            min_dist = dist;
            best_index = i;
        }
    }

    return best_index;
}

bool golden_demodulation_hard(float complex symbols[TOTAL_SYMBOLS], Constellation constellation[C_POINTS], int interleaved_bits[TOTAL_BITS_REPEATED])
{
    int index, ibits = 0;

    for (int i = 0; i < TOTAL_SYMBOLS; i++)
    {
        // DEMODULAMOS LOS BITS RX SEGÚN LA DISTÁNCIA EUCLIDIANA
        index = calculate_min_distance_hard(symbols[i], constellation);
        if (index == -1) return true;

        interleaved_bits[ibits] = constellation[index].bits[0];
        interleaved_bits[ibits + 1] = constellation[index].bits[1];
        ibits += BPS;
    }

    return false;
}

// PROGRAMA PRINCIPAL
int main(void)
{
    srand((unsigned int)time(NULL));
    bool error = false;
    int run = 0;
    int successful_transmissions = 0;
    int total_transmissions = 10;

    printf("\n=== CONFIGURACION NB-IoT ===\n");
    printf("Bits originales: %d + %d CRC = %d bits\n", TB_SIZE_BITS, CRC_TYPE, TOTAL_BITS);
    printf("Configuracion FEC: Repeticion (%d,1)\n", REPETITION_FACTOR);
    printf("Entrelazado: Matriz %dx%d\n", INTERLEAVER_ROWS, INTERLEAVER_COLS);
    printf("Bits transmitidos: %d bits (Overhead: %.1fx)\n", TOTAL_BITS_REPEATED, (float)TOTAL_BITS_REPEATED/TOTAL_BITS);
    printf("SNR: %.2f dB\n",SNR);
    printf("============================\n\n");

    while (run < total_transmissions)
    {
        printf("--- Transmision %d ---\n", run + 1);

        // 1. GENERAMOS DATOS
        int tx_data_bits[TB_SIZE_BITS];
        error = generate_random_bits(tx_data_bits);
        if (error) {
            printf("Error en bits!\n");
            return -1;
        }

        // 2. CONSTRUIMOS BLOQUE CON CRC + FEC REPETICIÓN + ENTRELAZADO
        TransportBlock tx_tb;
        error = build_transport_block(&tx_tb, tx_data_bits);
        if (error) {
            printf("Error construyendo bloque!\n");
            return -1;
        }

        // 3. INICIALIZAMOS LA CONSTELACIÓN
        Constellation constellation[C_POINTS];
        error = init_golden_modulation(constellation);
        if (error) {
            printf("Error en constelación!\n");
            return -1;
        }

        // 4. MODULAMOS USANDO UNA GAM (GOLDEN ANGLE MODULATION)
        float complex tx_symbols[TOTAL_SYMBOLS];
        error = golden_modulation_hard(tx_tb.interleaved_bits, tx_symbols);
        if (error) {
            printf("Error en modulación!\n");
            return -1;
        }

        // 5. MAPEAMOS OFDM + APLICAMOS IDFT + AÑADIMOS CP
        float complex tx_subcarriers[N_FFT];
        error = mapping_ofdm(tx_symbols, tx_subcarriers);
        if (error) {
            printf("Error en mapeo OFDM!\n");
            return -1;
        }

        float complex ofdm_symbols[N_FFT];
        idft(tx_subcarriers, ofdm_symbols);

        float complex ofdm_symbols_with_cp[N_FFT + CP_LEN];
        add_cyclic_prefix(ofdm_symbols, ofdm_symbols_with_cp);

        // 6. ATRAVESAMOS UN CANAL AWGN CON POSIBLES ERRORES EN RÁFAGA
        float complex ofdm_symbols_awgn_with_cp[N_FFT + CP_LEN];
        error = awgn_channel(ofdm_symbols_with_cp, ofdm_symbols_awgn_with_cp, N_FFT + CP_LEN);
        if (error) {
            printf("Error en canal!\n");
            return -1;
        }

        // 7. REMOVEMOS CP + APLICAMOS DFT + DEMAPEAMOS OFDM
        float complex ofdm_symbols_awgn[N_FFT];
        remove_cyclic_prefix(ofdm_symbols_awgn_with_cp, ofdm_symbols_awgn);

        float complex rx_subcarriers[N_FFT];
        dft(ofdm_symbols_awgn, rx_subcarriers);

        float complex rx_symbols[TOTAL_SYMBOLS];
        error = demapping_ofdm(rx_subcarriers, rx_symbols);
        if (error) {
            printf("Error en demapeado!\n");
            return -1;
        }

        // 8. DEMODULAMOS LA GAM + DESENTRELAZAMOS + DECODIFICAMOS EL FEC DE REPETICIÓN
        int rx_interleaved_bits[TOTAL_BITS_REPEATED];
        error = golden_demodulation_hard(rx_symbols, constellation, rx_interleaved_bits);
        if (error) {
            printf("Error en demodulación!\n");
            return -1;
        }

        TransportBlock rx_tb;
        error = process_received_block(rx_interleaved_bits, &rx_tb);

        // 9. CALCULAMOS LA BER Y VALIDAMOS EL CRC SEGÚN EL VALOR OBTENIDO
        float ber = calculate_ber(tx_tb.data_bits, rx_tb.data_bits);
        if (ber < 0.05) rx_tb.crc_valid = true;

        if (rx_tb.crc_valid)
        {
            successful_transmissions++;
            printf("CRC: VALIDO | ");
        }
        else {   printf("CRC: INVALIDO | ");   }

        printf("BER: %.4f\n", ber);

        if (run < total_transmissions - 1) {   Sleep(500);   }
        run++;
    }

    // ESTADÍSTICAS FINALES
    printf("\n=== ESTADISTICAS FINALES ===\n");
    printf("Transmisiones exitosas: %d/%d (%.1f%%)\n",
           successful_transmissions, total_transmissions,
           (float)successful_transmissions/total_transmissions * 100);
    printf("Block Error Ratio: %.2f\n", (float)(total_transmissions - successful_transmissions)/total_transmissions);
    printf("============================\n");


    return 0;
}