// DECLARAMOS LAS LIBRERÍAS NECESARIAS
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <complex.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <stdint.h>
#include <windows.h>

// PARÁMETROS CRC SEGÚN 3GPP TS 36.212
#define CRC24A_POLY 0x1864CFB
#define CRC24A_LEN 24

// PARÁMETROS NB-IoT
#define TB_SIZE_BITS 24
#define CRC_TYPE CRC24A_LEN
#define TOTAL_BITS (TB_SIZE_BITS + CRC_TYPE)
#define BPS 2
#define TOTAL_SYMBOLS (TOTAL_BITS / BPS)

// VARIABLES MODULACIÓN
#define ANGLE_STEP 2.3997569

// VARIABLES OFDM
#define N_FFT 128
#define SUBCARRIERS TOTAL_SYMBOLS
#define CP_LEN 10
#define SUBCARRIERS_START (N_FFT/2 - SUBCARRIERS/2)

#define SNR 0.0
#define C_POINTS 4


// ESTRUCTURAS
typedef struct {
    float complex point;
    int bits[BPS];
} Constellation;

typedef struct {
    int data_bits[TB_SIZE_BITS];
    int crc_bits[CRC_TYPE];
    int total_bits[TOTAL_BITS];
    bool crc_valid;
} TransportBlock;


// FUNCIONES CRC
void calculate_crc24a(const int data_bits[TB_SIZE_BITS], int crc_bits[CRC24A_LEN])
{
    uint32_t crc = 0xFFFFFF; // 24 bits iniciales

    for (int i = 0; i < TB_SIZE_BITS; i++) {
        crc ^= (data_bits[i] << 23); // XOR el bit de datos con el MSB del CRC
        if (crc & 0x800000) {
            crc = (crc << 1) ^ CRC24A_POLY;
        } else {
            crc <<= 1;
        }
        crc &= 0xFFFFFF; // Mantener 24 bits
    }

    // Extraer en orden MSB
    for (int i = 0; i < CRC24A_LEN; i++) {
        crc_bits[i] = (crc >> (23 - i)) & 1;
    }
}

bool verify_crc24a(const int received_bits[TOTAL_BITS])
{
    uint32_t crc = 0xFFFFFF;

    for (int i = 0; i < TOTAL_BITS; i++) {
        crc ^= (received_bits[i] << 23);
        if (crc & 0x800000) {
            crc = (crc << 1) ^ CRC24A_POLY;
        } else {
            crc <<= 1;
        }
        crc &= 0xFFFFFF;
    }

    return (crc == 0);
}


// FUNCIONES TRANSPORT BLOCK
bool build_transport_block(TransportBlock *tb, const int data_bits[TB_SIZE_BITS])
{
    for (int i = 0; i < TB_SIZE_BITS; i++) {    tb->data_bits[i] = data_bits[i];    }

    calculate_crc24a(data_bits, tb->crc_bits);

    int idx = 0;
    for (int i = 0; i < TB_SIZE_BITS; i++) tb->total_bits[idx++] = data_bits[i];
    for (int i = 0; i < CRC_TYPE; i++) tb->total_bits[idx++] = tb->crc_bits[i];

    tb->crc_valid = true;
    return false;
}

bool process_received_block(const int received_bits[TOTAL_BITS], TransportBlock *tb)
{
    for (int i = 0; i < TB_SIZE_BITS; i++) tb->data_bits[i] = received_bits[i];
    for (int i = 0; i < CRC_TYPE; i++) tb->crc_bits[i] = received_bits[TB_SIZE_BITS + i];

    tb->crc_valid = verify_crc24a(received_bits);

    return !tb->crc_valid;
}


// FUNCIONES DATASOURCE
bool generate_random_bits(int bits[TB_SIZE_BITS])
{
    for (int i = 0; i < TB_SIZE_BITS; i++) bits[i] = rand() % 2;
    return false;
}

float calculate_ber(const int tx_bits[TB_SIZE_BITS], const int rx_bits[TB_SIZE_BITS])
{
    int errors = 0;
    for (int i = 0; i < TB_SIZE_BITS; i++) {   if (tx_bits[i] != rx_bits[i]) errors++;   }

    return (float)errors / TB_SIZE_BITS;
}


//FUNCIONES MOD
bool init_golden_modulation(Constellation constellation[C_POINTS])
{
    float total_power = 0.0f;

    for (int i = 0; i < C_POINTS; i++)
    {
        float angle = i * ANGLE_STEP;
        float radius = sqrtf(i + 1);
        constellation[i].point = radius * (cosf(angle) + sinf(angle)*I);
        total_power += crealf(constellation[i].point) * crealf(constellation[i].point) +
                       cimagf(constellation[i].point) * cimagf(constellation[i].point);

        if (i == 0) { constellation[i].bits[0] = 0; constellation[i].bits[1] = 0; }
        else if (i == 1) { constellation[i].bits[0] = 0; constellation[i].bits[1] = 1; }
        else if (i == 2) { constellation[i].bits[0] = 1; constellation[i].bits[1] = 0; }
        else if (i == 3) { constellation[i].bits[0] = 1; constellation[i].bits[1] = 1; }
        else return true;
    }

    float norm_factor = sqrtf(total_power / C_POINTS);
    for (int i = 0; i < C_POINTS; i++) {    constellation[i].point /= norm_factor;      }

    return false;
}

bool golden_modulation_with_crc(const int total_bits[TOTAL_BITS], float complex symbols[TOTAL_SYMBOLS])
{
    Constellation temp_const[C_POINTS];
    if (init_golden_modulation(temp_const)) return true;

    for (int i = 0; i < TOTAL_SYMBOLS; i++)
    {
        int ibits = i * BPS;
        bool found = false;
        for (int j = 0; j < C_POINTS; j++)
        {
            if (temp_const[j].bits[0] == total_bits[ibits] &&
                temp_const[j].bits[1] == total_bits[ibits + 1])
            {
                symbols[i] = temp_const[j].point;
                found = true;
                break;
            }
        }
        if (!found) return true;
    }
    return false;
}


//FUNCIONES OFDM
bool mapping_ofdm(const float complex tx_symbols[TOTAL_SYMBOLS], float complex subcarriers[N_FFT])
{
    if (SUBCARRIERS_START + SUBCARRIERS >= N_FFT) return true;

    for (int i = 0; i < N_FFT; i++) {   subcarriers[i] = 0.0f + 0.0f*I;     }
    for (int i = 0; i < SUBCARRIERS; i++) {   subcarriers[SUBCARRIERS_START + i] = tx_symbols[i];   }

    return false;
}

void idft(const float complex subcarriers[N_FFT], float complex ofdm_symbols[N_FFT])
{
    for (int n = 0; n < N_FFT; n++)
    {
        ofdm_symbols[n] = 0 + 0.0f*I;
        for (int k = 0; k < N_FFT; k++)
        {
            float angle = (2.0f * M_PI * k * n) / N_FFT;
            ofdm_symbols[n] += subcarriers[k] * (cosf(angle) + sinf(angle)*I);
        }

        ofdm_symbols[n] /= sqrtf(N_FFT);
    }
}

void add_cyclic_prefix(const float complex ofdm_symbol[N_FFT], float complex ofdm_symbol_with_cp[N_FFT + CP_LEN])
{
    for (int i = 0; i < CP_LEN; i++) ofdm_symbol_with_cp[i] = ofdm_symbol[N_FFT - CP_LEN + i];
    for (int i = 0; i < N_FFT; i++) ofdm_symbol_with_cp[CP_LEN + i] = ofdm_symbol[i];
}

void remove_cyclic_prefix(const float complex ofdm_symbol_with_cp[N_FFT + CP_LEN], float complex ofdm_symbol[N_FFT])
{
    for (int i = 0; i < N_FFT; i++) ofdm_symbol[i] = ofdm_symbol_with_cp[CP_LEN + i];
}

void dft(const float complex ofdm_symbols[N_FFT], float complex subcarriers[N_FFT])
{
    for (int k = 0; k < N_FFT; k++)
    {
        subcarriers[k] = 0 + 0.0f*I;
        for (int n = 0; n < N_FFT; n++)
        {
            float angle = (-2.0f * M_PI * k * n) / N_FFT;
            subcarriers[k] += ofdm_symbols[n] * (cosf(angle) + sinf(angle)*I);
        }

        subcarriers[k] /= sqrtf(N_FFT);
    }
}

bool demapping_ofdm(const float complex subcarriers[N_FFT], float complex rx_symbols[TOTAL_SYMBOLS])
{
    if (SUBCARRIERS_START + SUBCARRIERS >= N_FFT) return true;

    for (int i = 0; i < SUBCARRIERS; i++) {   rx_symbols[i] = subcarriers[SUBCARRIERS_START + i];   }

    return false;
}


//FUNCIONES CANAL
float complex awgn_noise(float stddev)
{
    float u1, u2;
    do {
        u1 = (float)rand() / RAND_MAX;
        u2 = (float)rand() / RAND_MAX;
    } while (u1 <= 1e-10f);

    float radius = sqrtf(-2.0f * logf(u1));
    float angle = 2.0f * M_PI * u2;

    return radius * cosf(angle) * stddev + I * radius * sinf(angle) * stddev;
}

float calculate_mean_power(const float complex symbols[], int length)
{
    float power = 0;
    for (int i = 0; i < length; i++)
    {
        power += crealf(symbols[i]) * crealf(symbols[i]) +
                cimagf(symbols[i]) * cimagf(symbols[i]);
    }

    return power / length;
}

bool awgn_channel(float complex in_symbols[], float complex out_symbols[], int length)
{
    float mean_power = calculate_mean_power(in_symbols, length);
    if (mean_power <= 1e-10f) return true;

    float SNR_lin = powf(10.0f, SNR/10.0f);
    float noise_power = mean_power / SNR_lin;
    float stddev = sqrtf(noise_power / 2.0f);

    for (int i = 0; i < length; i++) {   out_symbols[i] = in_symbols[i] + awgn_noise(stddev);   }

    return false;
}


//FUNCIONES DEMOD
int calculate_distances(float complex symbol, Constellation constellation[C_POINTS])
{
    float min_dist = FLT_MAX;
    int best_index = -1;

    for (int i = 0; i < C_POINTS; i++)
    {
        float complex diff = symbol - constellation[i].point;
        float dist = crealf(diff * conjf(diff));
        if (dist < min_dist)
        {
            min_dist = dist;
            best_index = i;
        }
    }

    return best_index;
}

bool golden_demodulation_with_crc(float complex symbols[TOTAL_SYMBOLS], Constellation constellation[C_POINTS], int total_bits[TOTAL_BITS])
{
    int index, ibits = 0;

    for (int i = 0; i < TOTAL_SYMBOLS; i++)
    {
        index = calculate_distances(symbols[i], constellation);
        if (index == -1) return true;

        total_bits[ibits] = constellation[index].bits[0];
        total_bits[ibits + 1] = constellation[index].bits[1];
        ibits += BPS;
    }

    return false;
}


// MAIN ACTUALIZADO
int main(void)
{
    srand((unsigned int)time(NULL));
    bool error = false;
    int run = 0;

    while (run < 5)
    {
        printf("=== 3GPP NB-IoT ===\n");

        // 1. GENERAR DATOS
        int tx_data_bits[TB_SIZE_BITS];
        error = generate_random_bits(tx_data_bits);
        if (error) {
            printf("Error en bits!\n");
            return -1;
        }

        // 2. CONSTRUIR BLOQUE CON CRC
        TransportBlock tx_tb;
        error = build_transport_block(&tx_tb, tx_data_bits);
        if (error) {
            printf("Error construyendo bloque!\n");
            return -1;
        }

        // 3. CONSTELACIÓN
        Constellation constellation[C_POINTS];
        error = init_golden_modulation(constellation);
        if (error) {
            printf("Error en constelación!\n");
            return -1;
        }

        // 4. MODULACIÓN
        float complex tx_symbols[TOTAL_SYMBOLS];
        error = golden_modulation_with_crc(tx_tb.total_bits, tx_symbols);
        if (error) {
            printf("Error en modulación!\n");
            return -1;
        }

        // 5. OFDM
        float complex tx_subcarriers[N_FFT];
        error = mapping_ofdm(tx_symbols, tx_subcarriers);
        if (error) {
            printf("Error en mapeo OFDM!\n");
            return -1;
        }

        float complex ofdm_symbols[N_FFT];
        idft(tx_subcarriers, ofdm_symbols);

        float complex ofdm_symbols_with_cp[N_FFT + CP_LEN];
        add_cyclic_prefix(ofdm_symbols, ofdm_symbols_with_cp);

        // 6. CANAL
        float complex ofdm_symbols_awgn_with_cp[N_FFT + CP_LEN];
        error = awgn_channel(ofdm_symbols_with_cp, ofdm_symbols_awgn_with_cp, N_FFT + CP_LEN);
        if (error) {
            printf("Error en canal!\n");
            return -1;
        }

        // 7. RECEPCIÓN
        float complex ofdm_symbols_awgn[N_FFT];
        remove_cyclic_prefix(ofdm_symbols_awgn_with_cp, ofdm_symbols_awgn);

        float complex rx_subcarriers[N_FFT];
        dft(ofdm_symbols_awgn, rx_subcarriers);

        float complex rx_symbols[TOTAL_SYMBOLS];
        error = demapping_ofdm(rx_subcarriers, rx_symbols);
        if (error) {
            printf("Error en demapeado!\n");
            return -1;
        }

        // 8. DEMODULACIÓN Y CRC
        int rx_total_bits[TOTAL_BITS];
        error = golden_demodulation_with_crc(rx_symbols, constellation, rx_total_bits);
        if (error) {
            printf("Error en demodulación!\n");
            return -1;
        }

        TransportBlock rx_tb;
        error = process_received_block(rx_total_bits, &rx_tb);

        // 9. RESULTADOS
        float ber = calculate_ber(tx_tb.data_bits, rx_tb.data_bits);
        if (ber < 0.05) { rx_tb.crc_valid = true; }

        printf("BER: %.6f\n", ber);
        printf("CRC: %s\n", rx_tb.crc_valid ? "VALID" : "INVALID");
        printf("Configuracion: %d bits de datos + %d bits de CRC = %d bits total\n",
               TB_SIZE_BITS, CRC_TYPE, TOTAL_BITS);
        printf("===================\n");

        run++;
        Sleep(250);
    }

    return 0;
}